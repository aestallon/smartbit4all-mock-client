package com.aestallon.smartbit4all.mock.client.core.assertj;

import java.util.Objects;
import java.util.function.Consumer;
import java.util.function.Function;
import org.assertj.core.api.AssertProvider;
import org.assertj.core.api.Assertions;
import com.aestallon.smartbit4all.mock.client.core.exception.ClientException;
import com.aestallon.smartbit4all.mock.client.core.state.ClientComponent;

public abstract class AbstractComponentHandle<
    SELF extends AbstractComponentHandle<SELF, T, ASSERT>,
    T extends ClientComponent,
    ASSERT extends AbstractComponentAssert<ASSERT, T>
    >
    implements AssertProvider<ASSERT> {

  /**
   * Provides on-demand access to the client component.
   *
   * <p>
   * Every method interacting with the component invokes the locator to retrieve the component
   * itself from the client's current state. Thus, handles are reusable throughout an entire test
   * case.
   */
  protected final ComponentLocator<T> componentLocator;
  /**
   * Factory function responsible for creating assertion objects for a given component.
   *
   * <p>
   * The `assertFactory` encapsulates the logic to instantiate an assertion object for a specific
   * client component using the provided {@link ComponentLocator}. This is primarily used to enable
   * assertion capabilities for the client component, allowing validations and verifications in the
   * context of the component's state and behaviour.
   *
   * <p>
   * The assertions generated by this factory are specific to the type of the component being
   * handled and allow the implementation of fluent assertion patterns. This ensures consistent and
   * extensible assertion logic for various component types.
   */
  protected final Function<ComponentLocator<T>, ASSERT> assertFactory;

  protected AbstractComponentHandle(ComponentLocator<T> componentLocator,
                                    Function<ComponentLocator<T>, ASSERT> assertFactory) {
    this.componentLocator = Objects.requireNonNull(
        componentLocator,
        "Component Locator must not be null");
    this.assertFactory = assertFactory;
  }


  protected abstract SELF self();

  @Override
  public ASSERT assertThat() {
    return assertFactory.apply(componentLocator);
  }

  protected <R> R extract(String name, Function<T, R> extractor) {
    switch (componentLocator.get()) {
      case ComponentLocationResult.Some(T component, String specifier) -> {
        return extractor.apply(component);
      }
      case ComponentLocationResult.None(String specifier, String reason) -> {
        Assertions.fail("Could not retrieve " + name + " of " + specifier + " because " + reason);
        return null;
      }
    }
  }

  protected void interact(String description, Consumer<T> interaction) {
    switch (componentLocator.get()) {
      case ComponentLocationResult.Some(T component, String specifier) -> {
        try {
          interaction.accept(component);
        } catch (ClientException e) {
          e.fail();
        }
      }
      case ComponentLocationResult.None(String specifier, String reason) -> Assertions.fail(
          "Could not " + description + " " + specifier + " because " + reason);
    }
  }

}
